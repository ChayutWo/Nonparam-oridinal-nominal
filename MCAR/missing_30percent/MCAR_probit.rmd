
---
title: "MCAR 30% missing - Probit"
output:
  pdf_document: default
  html_document:
    highlight: pygments
    theme: spacelab
---

```{r setup, echo =FALSE, include=FALSE}
# DO NOT ALTER CODE IN THIS CHUNK
# The very first time you use this R markdown file, you should install each of the packages below.
# The same goes for other packages you might decide to use
# Remember that you only need to install each R package once in R (ever -- unless you change computers).
# All you need to do whenever you need to use the package again (after restarting the R session),
# is to use the library function to call the package.
# For example, type install.packages("knitr") in the console to install the knitr package. 
knitr::opts_chunk$set(echo = TRUE, fig.pos = 'h', fig.align = 'center')
knitr::opts_chunk$set(fig.cap = "",  fig.path = "Plot")
library(knitr)
library(dplyr)
library(arm)
library(pROC)
library(tidyverse)
library(MASS)
library(tigerstats)
library(leaps)
library(car)
library(rms)
require(caret)
require(e1071)
library(lme4) 
library(lattice)
library(broom)
library(boot)
library(ggplot2)
library(cobalt)
require(rstanarm)
require(magrittr)
require(rstan)
require(MCMCpack)
library(abind)
library(matrixStats)
library(truncnorm)
library(mvtnorm)
library(mnormt)
library(coda)
```

* * *

```{r}
# sample MCAR dataset from PUMS
source("../../utils/sampleMCAR.R")
n = 10000
missing_col = c(1,3,7,9,10,11)
missing_prob = 0.3
set.seed(0)

output_list <- sampleMCAR(n, missing_prob)
df <- output_list[['df']]
df_observed <- output_list[['df_observed']]
```


### Ordinal bayesian nonparametric model

```{r, echo = TRUE, results='hide'}
source("../../probitBayes_by_cluster.R")
N = 40
Mon = 1000
B = 1500
thin.int = 2
start = Sys.time()
# function(y, N = 40, Mon = 2000, B = 300, thin.int = 5, seed = 0)
output_list <- probitBayesImputation(df_observed, N, Mon, B, thin.int)
Sys.time() - start
```

```{r}
sampled_y <- output_list[['sampled_y']]
sampled_z <- output_list[['sampled_z']]

# extract 5 imputed dataset from probit model
imputation_index = as.integer(seq(1,dim(sampled_y)[1], length.out = 5))
imputation_list = list()

levels = c(7,7,7,19,5,4,7,2,17,3,13)
for (i in 1:length(imputation_index)) {
  index = imputation_index[i]
  # need to plus 1 here because the class index of DP function starts at 0
  d = sampled_y[index,,]
  d = data.frame(d)
  colnames(d) = colnames(df_observed)
  # format columns of d
  for (col_index in 1:ncol(df_observed)) {
    d[,col_index] = factor(d[,col_index], levels = 1:levels[col_index], ordered = TRUE)
  }
  imputation_list[[i]] = d
}
```

Diagnostics

Coverage

```{r}
source("../../utils/coverage.R")
coverage(imputation_list, n_way=2, missing_col)
```

RMSE

```{r}
source("../../utils/rmse.R")
rmse(imputation_list, n_way=1, missing_col)
```

MAE

```{r}
source("../../utils/mae.R")
mae(imputation_list, n_way=1, missing_col)
```

```{r}
source("../../utils/plot_hist.R")
imputted = plot_hist(imputation_list, df_observed, missing_col)
```

Assess convergence of MCMC
```{r, echo = FALSE}
# trace plot
z.mcmc <- mcmc(sampled_z[,1,11], start=1)
plot(z.mcmc)
```

```{r, echo = FALSE}
# auto correlation
autocorr.plot(z.mcmc)
```


Assess joint distribution

```{r}
source("../../utils/plot_pmf.R")
imputted = plot_pmf(imputation_list, n_way=2, missing_col)
imputted = plot_pmf(imputation_list, n_way=3, missing_col)
```

* * *



