library(MCMCpack)
library(mnormt)
library(coda)
library(NPBayesImputeCat)
# load dataset: df
load('../Datasets/ordinalPUMS.Rdata')
# take 10,000 samples: df
set.seed(0)
n = 10000
sample <- sample(nrow(df), size = 10000)
df <- df[sample,]
# create MCAR scneario with 30% chance of missing: df_observed
missing_prob = 0.3
df_observed <- df
missing_col = colnames(df)[c(1,3,5,7,9,11)]
for (col in missing_col) {
missing_ind <- rbernoulli(n,p = missing_prob)
df_observed[missing_ind, col] <- NA
}
N = 40
Mon = 2000
B = 300
thin.int = 5
# 1. Create and initialize the Rcpp_Lcm model object
model = CreateModel(X = df, MCZ = NULL, K = N, Nmax = 0,
aalpha = 0.25, balpha = 0.25, seed = 0)
# 2. Set tracer
model$SetTrace(c('k_star', 'psi', 'ImputedX', 'alpha'),Mon)
# 3. Run model using Run(burnin, iter, thinning)
model$Run(B,Mon,thin.int)
# Extract results
output <- model$GetTrace()
k_star <- output$k_star
psi <- output$psi
imputed_df <- output$ImputedX
alpha <- output$alpha
#retrieve parameters from the final iteration
result <- model$snapshot
#convert ImputedX matrix to dataframe, using proper factors/names etc.
ImputedX <- GetDataFrame(result$ImputedX,df)
dim(imputed_df)
for (var_index in c(1,3,5,7,9,11)) {
y_original = df[,var_index]
original_pmf = table(y_original)/length(y_original)
# Observed distribution
missing_indicator = is.na(df_observed)[,var_index]
y_observed = y_original[!missing_indicator]
observed_pmf = table(y_observed)/length(y_observed)
# Extract variable from imputed data
imputed_pmf = table(imputed_df[,seq(var_index, dim(imputed_df)[2], dim(df)[2])])
imputed_pmf = imputed_pmf/sum(imputed_pmf)
results = rbind(original_pmf,observed_pmf,imputed_pmf)
colnames(results)<- 1:dim(imputed_pmf)
barplot(results, xlab = 'Category', beside = TRUE,
legend = TRUE,
main = paste('Blocked Gibbs Sampling Assessment:', colnames(df)[var_index]))
}
# The number of clusters/latent groups used
plot(1:length(k_star), k_star, xlab = 'trials',
ylab = 'number of active clusters',
main = 'Number of clusters used over time', ylim = c(0,40))
# sampled alpha value for the stick breaking process
plot(1:length(alpha), alpha, xlab = 'trials',
ylab = 'alpha', type = 'l',
main = 'alpha value for the stick breaking process')
dim(imputed_df)
11000/2000
View(imputed_df)
# Compare joint distribution between var1 and var2 in the df
for (var1 in c(1,3,5,7,9,11)) {
for (var2 in c(1,3,5,7,9,11)) {
if (var2 > var1) {
# Compute the joint pmf in the original dataframe without missing values
original_pmf = table(df[,var1], df[,var2])
original_pmf = original_pmf/sum(original_pmf)
# Compute the joint pmf in the imputed dataset and average over imputations
imputed_pmf = table(imputed_df[,seq(var1, dim(imputed_df)[2], dim(df)[2])],
imputed_df[,seq(var2, dim(imputed_df)[2], dim(df)[2])])
imputed_pmf = imputed_pmf/sum(imputed_pmf)
# Calculate r square which is just correlation
r2 = cor(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1))
plot_title = paste('Bivariate pmf',
colnames(df)[var1], '&', colnames(df)[var2],
', r square:', round(r2,3))
plot(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1),
xlab = 'Original joint pmf', ylab = 'Imputed joint pmf',
main = plot_title)
abline(0,1, col = 'gray')
}
}
}
imputed_df[1:2,seq(var1, dim(imputed_df)[2], dim(df)[2])]
imputed_df[,seq(var1, 100, dim(df)[2])]
imputed_df[,seq(3, 100, dim(df)[2])]
imputed_df[,seq(4, 100, dim(df)[2])]
imputed_df[,seq(5, 100, dim(df)[2])]
imputed_df[,seq(6, 100, dim(df)[2])]
imputed_df[,seq(7, 100, dim(df)[2])]
imputed_df[,seq(9, 100, dim(df)[2])]
# load dataset: df
load('../Datasets/ordinalPUMS.Rdata')
# take 10,000 samples: df
set.seed(0)
n = 10000
sample <- sample(nrow(df), size = 10000)
df <- df[sample,]
# create MCAR scneario with 30% chance of missing: df_observed
missing_prob = 0.3
df_observed <- df
missing_col = colnames(df)[c(1,3,5,7,9,11)]
for (col in missing_col) {
missing_ind <- rbernoulli(n,p = missing_prob)
df_observed[missing_ind, col] <- NA
}
N = 40
Mon = 2000
B = 300
thin.int = 5
# 1. Create and initialize the Rcpp_Lcm model object
model = CreateModel(X = df, MCZ = NULL, K = N, Nmax = 0,
aalpha = 0.25, balpha = 0.25, seed = 0)
# 2. Set tracer
model$SetTrace(c('k_star', 'psi', 'ImputedX', 'alpha'),Mon)
# 3. Run model using Run(burnin, iter, thinning)
model$Run(B,Mon,thin.int)
# load dataset: df
load('../Datasets/ordinalPUMS.Rdata')
# take 10,000 samples: df
set.seed(0)
n = 10000
sample <- sample(nrow(df), size = 10000)
df <- df[sample,]
# create MCAR scneario with 30% chance of missing: df_observed
missing_prob = 0.3
df_observed <- df
missing_col = colnames(df)[c(1,3,5,7,9,11)]
for (col in missing_col) {
missing_ind <- rbernoulli(n,p = missing_prob)
df_observed[missing_ind, col] <- NA
}
N = 40
Mon = 2000
B = 300
thin.int = 5
# 1. Create and initialize the Rcpp_Lcm model object
model = CreateModel(X = df, MCZ = NULL, K = N, Nmax = 0,
aalpha = 0.25, balpha = 0.25, seed = 0)
# 2. Set tracer
model$SetTrace(c('k_star', 'psi', 'ImputedX', 'alpha'),Mon)
# 3. Run model using Run(burnin, iter, thinning)
model$Run(B,Mon,thin.int)
# Extract results
output <- model$GetTrace()
k_star <- output$k_star
psi <- output$psi
imputed_df <- output$ImputedX
alpha <- output$alpha
#retrieve parameters from the final iteration
result <- model$snapshot
#convert ImputedX matrix to dataframe, using proper factors/names etc.
ImputedX <- GetDataFrame(result$ImputedX,df)
for (var_index in c(1,3,5,7,9,11)) {
y_original = df[,var_index]
original_pmf = table(y_original)/length(y_original)
# Observed distribution
missing_indicator = is.na(df_observed)[,var_index]
y_observed = y_original[!missing_indicator]
observed_pmf = table(y_observed)/length(y_observed)
# Extract variable from imputed data
imputed_pmf = table(imputed_df[,seq(var_index, dim(imputed_df)[2], dim(df)[2])])
imputed_pmf = imputed_pmf/sum(imputed_pmf)
results = rbind(original_pmf,observed_pmf,imputed_pmf)
colnames(results)<- 1:dim(imputed_pmf)
barplot(results, xlab = 'Category', beside = TRUE,
legend = TRUE,
main = paste('Blocked Gibbs Sampling Assessment:', colnames(df)[var_index]))
}
# The number of clusters/latent groups used
plot(1:length(k_star), k_star, xlab = 'trials',
ylab = 'number of active clusters',
main = 'Number of clusters used over time', ylim = c(0,40))
# sampled alpha value for the stick breaking process
plot(1:length(alpha), alpha, xlab = 'trials',
ylab = 'alpha', type = 'l',
main = 'alpha value for the stick breaking process')
# Compare joint distribution between var1 and var2 in the df
for (var1 in c(1,3,5,7,9,11)) {
for (var2 in c(1,3,5,7,9,11)) {
if (var2 > var1) {
# Compute the joint pmf in the original dataframe without missing values
original_pmf = table(df[,var1], df[,var2])
original_pmf = original_pmf/sum(original_pmf)
# Compute the joint pmf in the imputed dataset and average over imputations
imputed_pmf = table(imputed_df[,seq(var1, dim(imputed_df)[2], dim(df)[2])],
imputed_df[,seq(var2, dim(imputed_df)[2], dim(df)[2])])
imputed_pmf = imputed_pmf/sum(imputed_pmf)
# Calculate r square which is just correlation
r2 = cor(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1))
plot_title = paste('Bivariate pmf',
colnames(df)[var1], '&', colnames(df)[var2],
', r square:', round(r2,3))
plot(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1),
xlab = 'Original joint pmf', ylab = 'Imputed joint pmf',
main = plot_title)
abline(0,1, col = 'gray')
}
}
}
small_df <- imputed_df[,1:100]
View(small_df)
# load dataset: df
load('../Datasets/ordinalPUMS.Rdata')
# take 10,000 samples: df
set.seed(0)
n = 10000
sample <- sample(nrow(df), size = 10000)
df <- df[sample,]
# create MCAR scneario with 30% chance of missing: df_observed
missing_prob = 0.3
df_observed <- df
missing_col = colnames(df)[c(1,3,5,7,9,11)]
for (col in missing_col) {
missing_ind <- rbernoulli(n,p = missing_prob)
df_observed[missing_ind, col] <- NA
}
View(df_observed)
# load dataset: df
load('../Datasets/ordinalPUMS.Rdata')
# take 10,000 samples: df
set.seed(0)
n = 10000
sample <- sample(nrow(df), size = 10000)
df <- df[sample,]
# create MCAR scneario with 30% chance of missing: df_observed
missing_prob = 0.3
df_observed <- df
missing_col = colnames(df)[c(1,3,5,7,9,11)]
for (col in missing_col) {
missing_ind <- rbernoulli(n,p = missing_prob)
df_observed[missing_ind, col] <- NA
}
N = 40
Mon = 2000
B = 300
thin.int = 5
# 1. Create and initialize the Rcpp_Lcm model object
model = CreateModel(X = df_observed, MCZ = NULL, K = N, Nmax = 0,
aalpha = 0.25, balpha = 0.25, seed = 0)
# 2. Set tracer
model$SetTrace(c('k_star', 'psi', 'ImputedX', 'alpha'),Mon)
# 3. Run model using Run(burnin, iter, thinning)
model$Run(B,Mon,thin.int)
# Extract results
output <- model$GetTrace()
k_star <- output$k_star
psi <- output$psi
imputed_df <- output$ImputedX
alpha <- output$alpha
#retrieve parameters from the final iteration
result <- model$snapshot
#convert ImputedX matrix to dataframe, using proper factors/names etc.
ImputedX <- GetDataFrame(result$ImputedX,df)
for (var_index in c(1,3,5,7,9,11)) {
y_original = df[,var_index]
original_pmf = table(y_original)/length(y_original)
# Observed distribution
missing_indicator = is.na(df_observed)[,var_index]
y_observed = y_original[!missing_indicator]
observed_pmf = table(y_observed)/length(y_observed)
# Extract variable from imputed data
imputed_pmf = table(imputed_df[,seq(var_index, dim(imputed_df)[2], dim(df)[2])])
imputed_pmf = imputed_pmf/sum(imputed_pmf)
results = rbind(original_pmf,observed_pmf,imputed_pmf)
colnames(results)<- 1:dim(imputed_pmf)
barplot(results, xlab = 'Category', beside = TRUE,
legend = TRUE,
main = paste('Blocked Gibbs Sampling Assessment:', colnames(df)[var_index]))
}
# The number of clusters/latent groups used
plot(1:length(k_star), k_star, xlab = 'trials',
ylab = 'number of active clusters',
main = 'Number of clusters used over time', ylim = c(0,40))
# sampled alpha value for the stick breaking process
plot(1:length(alpha), alpha, xlab = 'trials',
ylab = 'alpha', type = 'l',
main = 'alpha value for the stick breaking process')
# Compare joint distribution between var1 and var2 in the df
for (var1 in c(1,3,5,7,9,11)) {
for (var2 in c(1,3,5,7,9,11)) {
if (var2 > var1) {
# Compute the joint pmf in the original dataframe without missing values
original_pmf = table(df[,var1], df[,var2])
original_pmf = original_pmf/sum(original_pmf)
# Compute the joint pmf in the imputed dataset and average over imputations
imputed_pmf = table(imputed_df[,seq(var1, dim(imputed_df)[2], dim(df)[2])],
imputed_df[,seq(var2, dim(imputed_df)[2], dim(df)[2])])
imputed_pmf = imputed_pmf/sum(imputed_pmf)
# Calculate r square which is just correlation
r2 = cor(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1))
plot_title = paste('Bivariate pmf',
colnames(df)[var1], '&', colnames(df)[var2],
', r square:', round(r2,3))
plot(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1),
xlab = 'Original joint pmf', ylab = 'Imputed joint pmf',
main = plot_title)
abline(0,1, col = 'gray')
}
}
}
small_df <- imputed_df[,1:100]
View(small_df)
# load dataset: df
load('../Datasets/ordinalPUMS.Rdata')
# take 10,000 samples: df
set.seed(0)
n = 10000
sample <- sample(nrow(df), size = 10000)
df <- df[sample,]
# create MCAR scneario with 30% chance of missing: df_observed
missing_prob = 0.3
df_observed <- df
missing_col = colnames(df)[c(1,3,5,7,9,11)]
for (col in missing_col) {
missing_ind <- rbernoulli(n,p = missing_prob)
df_observed[missing_ind, col] <- NA
}
library(mice)
imputed_df <-  mice(df_observed,m=5,method="cart",print=F)
d1 <-  complete(imputed_df, 1)
d2 <-  complete(imputed_df, 2)
d3 <-  complete(imputed_df, 3)
d4 <-  complete(imputed_df, 4)
d5 <-  complete(imputed_df, 5)
for (var_index in c(1,3,5,7,9,11)) {
y_original = df[,var_index]
original_pmf = table(y_original)/length(y_original)
# Observed distribution
missing_indicator = is.na(df_observed)[,var_index]
y_observed = y_original[!missing_indicator]
observed_pmf = table(y_observed)/length(y_observed)
# Extract variable from imputed data
sample_estimate1 = table(d1[,var_index])/length(d1[,var_index])
sample_estimate2 = table(d2[,var_index])/length(d2[,var_index])
sample_estimate3 = table(d3[,var_index])/length(d3[,var_index])
sample_estimate4 = table(d4[,var_index])/length(d4[,var_index])
sample_estimate5 = table(d5[,var_index])/length(d5[,var_index])
imputed_pmf = (sample_estimate1 + sample_estimate2 + sample_estimate3 +
sample_estimate4 + sample_estimate5)/5
results = rbind(original_pmf,observed_pmf,imputed_pmf)
colnames(results)<- 1:dim(imputed_pmf)
barplot(results, xlab = 'Category', beside = TRUE,
legend = TRUE,
main = paste('MICE-CART:', colnames(df)[var_index]))
}
# Compare joint distribution between var1 and var2 in the df
for (var1 in c(1,3,5,7,9,11)) {
for (var2 in c(1,3,5,7,9,11)) {
if (var2 > var1) {
# Compute the joint pmf in the original dataframe without missing values
original_pmf = table(df[,var1], df[,var2])
original_pmf = original_pmf/sum(original_pmf)
# Compute the joint pmf in the imputed dataset and average over imputations
imputed_pmf = rbind(d1, d2, d3, d4, d5)
imputed_pmf = table(imputed_pmf[,var1], imputed_pmf[,var2])
imputed_pmf = imputed_pmf/sum(imputed_pmf)
# Calculate r square which is just correlation
r2 = cor(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1))
plot_title = paste('Bivariate pmf',
colnames(df)[var1], '&', colnames(df)[var2],
', r square:', round(r2,3))
plot(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1),
xlab = 'Original joint pmf', ylab = 'Imputed joint pmf',
main = plot_title)
abline(0,1, col = 'gray')
}
}
}
# load dataset: df
load('../Datasets/ordinalPUMS.Rdata')
# take 10,000 samples: df
set.seed(0)
n = 10000
sample <- sample(nrow(df), size = 10000)
df <- df[sample,]
# create MCAR scneario with 30% chance of missing: df_observed
missing_prob = 0.3
df_observed <- df
missing_col = colnames(df)[c(1,3,5,7,9,11)]
for (col in missing_col) {
missing_ind <- rbernoulli(n,p = missing_prob)
df_observed[missing_ind, col] <- NA
}
df.imp <- missForest(df_observed, verbose = FALSE)
d1 <-  df.imp$ximp
df.imp <- missForest(df_observed, verbose = FALSE)
d2 <-  df.imp$ximp
df.imp <- missForest(df_observed, verbose = FALSE)
d3 <-  df.imp$ximp
df.imp <- missForest(df_observed, verbose = FALSE)
d4 <-  df.imp$ximp
df.imp <- missForest(df_observed, verbose = FALSE)
d5 <-  df.imp$ximp
for (var_index in c(1,3,5,7,9,11)) {
y_original = df[,var_index]
original_pmf = table(y_original)/length(y_original)
# Observed distribution
missing_indicator = is.na(df_observed)[,var_index]
y_observed = y_original[!missing_indicator]
observed_pmf = table(y_observed)/length(y_observed)
# Extract variable from imputed data
sample_estimate1 = table(d1[,var_index])/length(d1[,var_index])
sample_estimate2 = table(d2[,var_index])/length(d2[,var_index])
sample_estimate3 = table(d3[,var_index])/length(d3[,var_index])
sample_estimate4 = table(d4[,var_index])/length(d4[,var_index])
sample_estimate5 = table(d5[,var_index])/length(d5[,var_index])
imputed_pmf = (sample_estimate1 + sample_estimate2 + sample_estimate3 +
sample_estimate4 + sample_estimate5)/5
results = rbind(original_pmf,observed_pmf,imputed_pmf)
colnames(results)<- 1:dim(imputed_pmf)
barplot(results, xlab = 'Category', beside = TRUE,
legend = TRUE,
main = paste('MICE:', colnames(df)[var_index]))
}
# Compare joint distribution between var1 and var2 in the df
for (var1 in c(1,3,5,7,9,11)) {
for (var2 in c(1,3,5,7,9,11)) {
if (var2 > var1) {
# Compute the joint pmf in the original dataframe without missing values
original_pmf = table(df[,var1], df[,var2])
original_pmf = original_pmf/sum(original_pmf)
# Compute the joint pmf in the imputed dataset and average over imputations
imputed_pmf = rbind(d1, d2, d3, d4, d5)
imputed_pmf = table(imputed_pmf[,var1], imputed_pmf[,var2])
imputed_pmf = imputed_pmf/sum(imputed_pmf)
# Calculate r square which is just correlation
r2 = cor(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1))
plot_title = paste('Bivariate pmf',
colnames(df)[var1], '&', colnames(df)[var2],
', r square:', round(r2,3))
plot(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1),
xlab = 'Original joint pmf', ylab = 'Imputed joint pmf',
main = plot_title)
abline(0,1, col = 'gray')
}
}
}
# load dataset: df
load('../Datasets/ordinalPUMS.Rdata')
# take 10,000 samples: df
set.seed(0)
n = 10000
sample <- sample(nrow(df), size = 10000)
df <- df[sample,]
# create MCAR scneario with 30% chance of missing: df_observed
missing_prob = 0.3
df_observed <- df
missing_col = colnames(df)[c(1,3,5,7,9,11)]
for (col in missing_col) {
missing_ind <- rbernoulli(n,p = missing_prob)
df_observed[missing_ind, col] <- NA
}
library(mice)
imputed_df <-  mice(df_observed,m=5,print=F)
d1 <-  complete(imputed_df, 1)
d2 <-  complete(imputed_df, 2)
d3 <-  complete(imputed_df, 3)
d4 <-  complete(imputed_df, 4)
d5 <-  complete(imputed_df, 5)
for (var_index in c(1,3,5,7,9,11)) {
y_original = df[,var_index]
original_pmf = table(y_original)/length(y_original)
# Observed distribution
missing_indicator = is.na(df_observed)[,var_index]
y_observed = y_original[!missing_indicator]
observed_pmf = table(y_observed)/length(y_observed)
# Extract variable from imputed data
sample_estimate1 = table(d1[,var_index])/length(d1[,var_index])
sample_estimate2 = table(d2[,var_index])/length(d2[,var_index])
sample_estimate3 = table(d3[,var_index])/length(d3[,var_index])
sample_estimate4 = table(d4[,var_index])/length(d4[,var_index])
sample_estimate5 = table(d5[,var_index])/length(d5[,var_index])
imputed_pmf = (sample_estimate1 + sample_estimate2 + sample_estimate3 +
sample_estimate4 + sample_estimate5)/5
results = rbind(original_pmf,observed_pmf,imputed_pmf)
colnames(results)<- 1:dim(imputed_pmf)
barplot(results, xlab = 'Category', beside = TRUE,
legend = TRUE,
main = paste('MICE:', colnames(df)[var_index]))
}
# Compare joint distribution between var1 and var2 in the df
for (var1 in c(1,3,5,7,9,11)) {
for (var2 in c(1,3,5,7,9,11)) {
if (var2 > var1) {
# Compute the joint pmf in the original dataframe without missing values
original_pmf = table(df[,var1], df[,var2])
original_pmf = original_pmf/sum(original_pmf)
# Compute the joint pmf in the imputed dataset and average over imputations
imputed_pmf = rbind(d1, d2, d3, d4, d5)
imputed_pmf = table(imputed_pmf[,var1], imputed_pmf[,var2])
imputed_pmf = imputed_pmf/sum(imputed_pmf)
# Calculate r square which is just correlation
r2 = cor(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1))
plot_title = paste('Bivariate pmf',
colnames(df)[var1], '&', colnames(df)[var2],
', r square:', round(r2,3))
plot(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1),
xlab = 'Original joint pmf', ylab = 'Imputed joint pmf',
main = plot_title)
abline(0,1, col = 'gray')
}
}
}
