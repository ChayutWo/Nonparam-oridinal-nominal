
---
title: "Testing different imputation methods on PUMS (MCAR) - DPMPM"
output:
  pdf_document: default
  html_document:
    highlight: pygments
    theme: spacelab
---

```{r setup, echo =FALSE, include=FALSE}
# DO NOT ALTER CODE IN THIS CHUNK
# The very first time you use this R markdown file, you should install each of the packages below.
# The same goes for other packages you might decide to use
# Remember that you only need to install each R package once in R (ever -- unless you change computers).
# All you need to do whenever you need to use the package again (after restarting the R session),
# is to use the library function to call the package.
# For example, type install.packages("knitr") in the console to install the knitr package. 
knitr::opts_chunk$set(echo = TRUE, fig.pos = 'h', fig.align = 'center')
knitr::opts_chunk$set(fig.cap = "",  fig.path = "Plot")
library(knitr)
library(dplyr)
library(arm)
library(pROC)
library(tidyverse)
library(MASS)
library(tigerstats)
library(leaps)
library(car)
library(rms)
require(caret)
require(e1071)
library(lme4) 
library(lattice)
library(broom)
library(boot)
library(ggplot2)
library(cobalt)
require(tidyverse)
require(rstanarm)
require(magrittr)
require(rstan)
require(MCMCpack)
library(abind)
library(matrixStats)
library(truncnorm)
library(mvtnorm)
library(MCMCpack)
library(mnormt)
library(coda)
library(NPBayesImputeCat)
```

* * *
```{r}
# load dataset: df
load('../Datasets/ordinalPUMS.Rdata')

# take 10,000 samples: df
set.seed(0)
n = 10000
sample <- sample(nrow(df), size = 10000)
df <- df[sample,]

# create MCAR scneario with 30% chance of missing: df_observed
missing_prob = 0.3
df_observed <- df
missing_col = colnames(df)[c(1,3,5,7,9,11)]
for (col in missing_col) {
  missing_ind <- rbernoulli(n,p = missing_prob)
  df_observed[missing_ind, col] <- NA
}
```


### DPMPM

Multiple imputation using NPBayesImputeCat package

Ref: https://cran.r-project.org/web/packages/NPBayesImputeCat/NPBayesImputeCat.pdf

1. Create and initialize the Rcpp_Lcm model object using CreateModel with the following arguments:
  - X: dataframe to be imptuted = df
  - MCZ: dataframe with the definition of structural zero = NULL
  - K: the maximum number of mixture components = 40
  - Nmax: An upper truncation limit for the augmented sample size = 0
  - aalpha: the hyper parameter alpha in stick-breaking prior = 0.25
  - balpha: the hyper parameter beta in stick-breaking prior = 0.25
  - seed = 0

2. Set the tracer for the sampling process
  - k_star: the effective cluster number
  - psi: conditional multinomial probabilties
  - ImputedX: imputation result

3. Run the model using the method Run of Rcpp_Lcm class with the following arguments:
  - burnin = 300
  - iter = 2000
  - thinning = 5

4. Obtain result

```{r, results = 'hide'}
N = 40
Mon = 2000
B = 300
thin.int = 5

# 1. Create and initialize the Rcpp_Lcm model object
model = CreateModel(X = df_observed, MCZ = NULL, K = N, Nmax = 0,
                    aalpha = 0.25, balpha = 0.25, seed = 0)
# 2. Set tracer
model$SetTrace(c('k_star', 'psi', 'ImputedX', 'alpha'),Mon)

# 3. Run model using Run(burnin, iter, thinning)
model$Run(B,Mon,thin.int)
```


```{r}
# Extract results
output <- model$GetTrace()
k_star <- output$k_star
psi <- output$psi
imputed_df <- output$ImputedX
alpha <- output$alpha

#retrieve parameters from the final iteration 
result <- model$snapshot

#convert ImputedX matrix to dataframe, using proper factors/names etc. 
ImputedX <- GetDataFrame(result$ImputedX,df)
```

Diagnostics

```{r}
for (var_index in c(1,3,5,7,9,11)) {
  y_original = df[,var_index]
  original_pmf = table(y_original)/length(y_original)
  
  # Observed distribution
  missing_indicator = is.na(df_observed)[,var_index]
  y_observed = y_original[!missing_indicator]
  observed_pmf = table(y_observed)/length(y_observed)
  
  # Extract variable from imputed data
  imputed_pmf = table(imputed_df[,seq(var_index, dim(imputed_df)[2], dim(df)[2])])
  imputed_pmf = imputed_pmf/sum(imputed_pmf)
  
  results = rbind(original_pmf,observed_pmf,imputed_pmf)
  colnames(results)<- 1:dim(imputed_pmf)
  barplot(results, xlab = 'Category', beside = TRUE, 
          legend = TRUE, 
          main = paste('Blocked Gibbs Sampling Assessment:', colnames(df)[var_index]))
}
```


```{r, echo = FALSE}
# The number of clusters/latent groups used
plot(1:length(k_star), k_star, xlab = 'trials', 
     ylab = 'number of active clusters', 
     main = 'Number of clusters used over time', ylim = c(0,40))
```

```{r, echo = FALSE}
# sampled alpha value for the stick breaking process
plot(1:length(alpha), alpha, xlab = 'trials', 
     ylab = 'alpha', type = 'l',
     main = 'alpha value for the stick breaking process')
```

Assess bivariate joint distribution
```{r}
# Compare joint distribution between var1 and var2 in the df
for (var1 in c(1,3,5,7,9,11)) {
  for (var2 in c(1,3,5,7,9,11)) {
    if (var2 > var1) {
      # Compute the joint pmf in the original dataframe without missing values
      original_pmf = table(df[,var1], df[,var2])
      original_pmf = original_pmf/sum(original_pmf)
      
      # Compute the joint pmf in the imputed dataset and average over imputations
      imputed_pmf = table(imputed_df[,seq(var1, dim(imputed_df)[2], dim(df)[2])],
                          imputed_df[,seq(var2, dim(imputed_df)[2], dim(df)[2])])
      imputed_pmf = imputed_pmf/sum(imputed_pmf)
      
      # Calculate r square which is just correlation
      r2 = cor(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1))
      plot_title = paste('Bivariate pmf', 
                         colnames(df)[var1], '&', colnames(df)[var2], 
                         ', r square:', round(r2,3))
      
      plot(matrix(original_pmf, ncol = 1), matrix(imputed_pmf, ncol = 1), 
           xlab = 'Original joint pmf', ylab = 'Imputed joint pmf', 
           main = plot_title)
      abline(0,1, col = 'gray')
    }
  }
}
```


* * *



